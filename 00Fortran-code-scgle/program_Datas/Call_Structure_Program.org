* Hard_sphere_dynamics(.True.,.True.,.True.)
  is In File:program.f90  

  Line define:28

  Line_Call : 16  
** Sys_Variables_Alloc(species)

   is In File: variables_modules.f90

   Module: System_Variables

   Line Define: 27

   Line Call: 49
   
** D0M_ini (species,sigma) !Diffusion coefficient of the system particle
   is In File: variables_modules.f90

   Module:System_Variables

   Line Define: 39

   Line Call: 57
   
** rho_ini()
   is In File: variables_modules.f90

   Module: System_Variables

   Line Define: 55

   Line Call: 60
   
** Static_Variables_mem_alloc(kpoints,species)
   is In File: variables_modules.f90

   Module: Static_Variables

   Line Define: 116

   Line Call: 62
** Calc_static_k(dk,kpoints)
   File Defined: variables_modules.f90
   Module: Static_Variables
   Line Define: 116
   Line Call: 63
   
** Calc_Sk_hs_py_mono #####Finally
   is inFile: structure_module.f90

   Module: Structure_module

   Line Define:24

   Line Call: 65    

 *Code snippet*
 #+begin_src fortran
Subroutine Calc_Sk_hs_py_mono(vw_option)
    Implicit None
    Integer :: i1                                                     ! Define an entire variable
    Logical :: vw_option                                              ! Define an Boolean Variable 
    Real * 8, Dimension(:), Allocatable :: k_vw                       ! Define a Vector, Dynamic Memory. Float type with 8 points of presicion.
    Real * 8 :: eta_vw,dum1,dum2,dum3,dum4,dumsin,dumcos              ! Define severals Float type with 8 points of presicion.
    !Start of parameter checks
    If (SDimen/= 3 .or. Species /=1 ) Then                            !Make desicion for determinate if system can compute 
       print*, ('Error, cannot compute the system direct correlation function')
       Stop
    End If
    !End of parameter checks    
    
    !### Here we must to watch the value for kpoints
    !The value of kpoints is persistent, obviously xD : p
    Allocate(k_vw(kpoints))                                           ! Allocate memory for k_vw vector Syntax:Allocate(Identifier(syze))
    
    !Start of VW Correction
    If (vw_option .EQV. .TRUE.) Then                                  ! Make desicion this also could be: If(vw_option) Then 
       !Some data are calculated
       eta_vw=eta(1)*(1.d0-(eta(1)/16.d0))
       !####################################################################################################################################
       !#########Analize space #######################
       !This instruction is interesting cause in this line whole array is traveled, this sintax is called modern fortran.
       k_vw(:)=k(:)*((eta_vw/eta(1))**(1.d0/3.d0))
       !####################################################################################################################################
    Else
       eta_vw=eta(1)                                                  ! eta()
       k_vw(:)=k(:)
    End If
    !End of VW correction
    dum1=-((1.0+2.0*eta_vw)**2)
    dum2=6.0*eta_vw*((1.0+(eta_vw/2.0))**2)
    dum3=-eta_vw*((1.0+(2.0*eta_vw))**2)/2.0
    dum4=((1.0-eta_vw)**4)
    dum1=dum1/dum4
    dum2=dum2/dum4
    dum3=dum3/dum4
    Do i1=1, kpoints
       dumsin=sin(k_vw(i1))
       dumcos=cos(k_vw(i1))
       !####################################################################################################################################
       !#########Analize space #######################
       !This sintax  
       !                 ck(i1,1,1)= (dum1*(dumsin-k_vw(i1)*dumcos)/(k_vw(i1)**2.d0))+&
       !                 &%&(%&/"#$Other line.......
       ! Is used for concat severals lines of code as one 
       
       !This is the same 
       ck(i1,1,1)= (dum1*(dumsin-k_vw(i1)*dumcos)/(k_vw(i1)**2.d0))+&
            &(dum2*(((2.d0*k_vw(i1))*dumsin)+((-(k_vw(i1)**2.d0)+2.d0)*dumcos)-2.d0)/&
            &(k_vw(i1)**3.d0))+(dum3*(((4.d0*(k_vw(i1)**3.d0)-24.0*k_vw(i1))*dumsin)&
            &+((-(k_vw(i1)**4.d0)+12.d0*(k_vw(i1)**2.d0)-24.d0)*dumcos)+24.d0)/(k_vw(i1)**5))
       !to This
       !ck(i1,1,1)= (dum1*(dumsin-k_vw(i1)*dumcos)/(k_vw(i1)**2.d0))+ &&(dum2*(((2.d0*k_vw(i1))*dumsin)+((-(k_vw(i1)**2.d0)+2.d0)*dumcos)-2.d0)/&&(k_vw(i1)**3.d0))+(dum3*(((4.d0*(k_vw(i1)**3.d0)-24.0*k_vw(i1))*dumsin)&&+((-(k_vw(i1)**4.d0)+12.d0*(k_vw(i1)**2.d0)-24.d0)*dumcos)+24.d0)/(k_vw(i1)**5))
       Ck(i1,1,1)=  24.d0*eta_vw*ck(i1,1,1)/k_vw(i1)
       Sk(i1,1,1)=1.d0/(1.d0-ck(i1,1,1))
       Ski(i1,1,1)=1.d0-Ck(i1,1,1)
    End Do
  End Subroutine Calc_Sk_hs_py_mono

    #+end_src

